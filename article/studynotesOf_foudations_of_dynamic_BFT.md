# Foundations of Dynamic BFT

> S. Duan and H. Zhang, "Foundations of Dynamic BFT," 2022 IEEE Symposium on Security and Privacy (SP), 2022, pp. 1317-1334, doi: 10.1109/SP46214.2022.9833787.

本文研究了动态 BFT，其中副本可以动态地加入和离开系统，这是当今越来越需要的一种原语。我们**为动态 BFT 协议提供形式化处理**，赋予它们灵活的语法和各种安全定义。我们展示了**将静态 BFT 扩展到动态 BFT 的挑战**。然后我们**设计并实现了部分同步模型下的高效动态 BFT 协议 Dyno**。我们展示了 Dyno 可以无缝处理成员资格更改，而不会导致性能下降。

拜占庭容错状态机(state machine)复制 (BFT) 传统上被称为构建关键任务系统的原语。如今，BFT 获得了突出地位，因为它被视为区块链的核心构建块：BFT 被称为许可区块链的模型 [54]，其中成员资格是静态的，分类帐（副本）知道彼此的身份，但可能不信任彼此。 BFT 也越来越多地以各种方式在无许可区块链中使用（这些协议也称为混合区块链 [26、27、56]）。本文研究了具有动态成员资格的 BFT，或简称为动态 BFT，其中副本可以动态地加入和离开系统。动态 BFT 是一种传统上可能被视为从系统角度实现理想功能的原语，如今越来越需要作为无数区块链和安全应用程序的核心构建块。

**正常恢复和重新配置**。与任何静态分布式系统一样，静态 BFT 系统具有实际限制 [46]：例如，如果其中一个副本崩溃、需要维护或被认为有故障，则系统始终可用的概率减少。恢复有故障的节点可能并不总是可行的，因为恢复节点可能需要时间，更重要的是，恢复可能并不总是可行的（例如，由于永久性硬件故障）。在这种情况下，更好的方法是创建一个新副本来替换有故障的副本

**主动恢复**。动态 BFT 可用于构建具有长期主动恢复功能的强大 BFT 系统。在许多先前的工作中已经研究了主动安全 BFT 系统的问题 [10, 51]。这些系统使用受信任的硬件来定期重启节点，希望它能驱逐对手。然而，对手（例如病毒）很可能会留在系统中，从而使这些努力毫无用处。然而，新鲜的副本没有这样的问题。因此，动态 BFT 为传统的主动恢复方法提供了一种替代方案，可以说是更好的解决方案。

**联盟区块链**。 BFT 的静态成员属性可能会极大地限制联盟区块链的适用性。区块链实体可以选择（或被迫）离开联盟，而新实体可以加入联盟。例如，现在更名为 Diem 的 Libra 已经面临这样一种情况，在 BFT 达成协议后，动态成员资格由其智能合约管理。

**混合区块链**。使用 BFT 的混合区块链需要选择固定数量的 BFT 副本，称为委员会，很容易成为坐鸭。能够在保持系统正常运行的同时更换委员会是至关重要的。



### challenges and contribution

 **动态 BFT 的规范化处理**。尽管需要动态 BFT，但到目前为止，还没有为动态 BFT 提供严格的形式化。虽然在崩溃故障模型 [11, 46] 和拜占庭故障模型 [20, 39, 40] 中定义了一些相关的原语，但对于具有可证明安全性的动态 BFT 缺乏良好的抽象。从现代的角度来看动态 BFT——在“区块链时代”——早就应该了。本文填补了这一空白，并提供了对动态 BFT 的正式处理。我们的规范涵盖了将 BFT 与成员服务分开的语法，这是一种源自 Schipper 为崩溃故障模型 [46] 所做的工作的方法。然而，我们对安全性的定义发生了相当不同的转变，通过处理模糊不清的常规请求和成员请求。更重要的是，我们的处理具有以下两个特征：

* 在将安全定义提升到动态 BFT 时，我们定义了一个新属性（一致交付），我们发现它对动态 BFT 的安全性至关重要。我们展示了一些自然的和替代的交付属性无法正常工作。
* 我们的处理包括针对动态拜占庭容错“正确”的不同概念的许多安全定义，每一个都是有意义的，从我们可以设想的最弱到最强。

**确定动态 BFT 的（新）问题**。尽管对动态成员资格（主要在崩溃容错系统中）进行了长期的工作，但我们发现了一些（新）问题：

* 由于动态仲裁（在第 IV 节中指定）引起的问题。在动态 BFT 中，成员变化导致法定人数的变化，造成各种活跃度问题。 
* 由于视图更改而产生的问题（在第 IV 节中指定）。在具有视图更改（即领导者选举）的动态 BFT 中，也存在各种问题。例如，下一个领导者可能无法收集到足够的视图更改消息，甚至可能不知道视图更改的发生。更糟糕的是，多个副本可能声称它们是同一视图中的领导者。
* 消息传递引起的问题（在第 III-E 节中指定）。静态分布式系统有一个消息传递假设，即在正确的副本之间传输的消息最终会被传递。这个假设不适用于动态设置，因为一些正确的副本虽然在发送消息时是正确的，但可能会在未来的某些配置中离开系统。我们发现，即使是安全分布式计算社区中的一些经典协议（例如，[46]）也只是假设跨配置的消息传递，而这些协议的证明实际上是有缺陷的。

**配置发现协议**。我们的协议依赖于配置发现子协议，其中客户端和新副本获得系统的成员资格。配置发现协议不仅从功能的角度来看是至关重要的，而且对于我们动态 BFT 协议的正确性也是如此。我们提供了一个这样的协议，它使用显式成员发现。我们还在附录中介绍了两个使用隐式成员发现的替代协议。

**构造、假设及其表示**。我们考虑两个不同的假设：**标准群体假设**（假设每个配置的最佳弹性）和 **G-correct 假设**（假设一小部分正确的副本永远不会离开系统）。基于每个假设，我们提供满足我们提出的不同安全定义的协议。我们首先介绍本文的主要协议 Dyno。然后我们介绍 Dyno 的变体。我们正式证明了所有协议的安全性。我们的目标之一是无缝处理成员变更。 Dyno 保留了底层 BFT 协议的全部效率，并且可以独立于视图更改处理成员请求。然而，Dyno 确实对底层 BFT 协议的正常情况操作和视图更改机制进行了重大修改，同时没有增加性能开销。我们展示了 Dyno 在各种加入和离开场景下是高效和健壮的。

### related work

**BFT**。作为一种容忍任意故障的通用方法，BFT 可以分为同步 BFT 、部分同步 BFT  和异步 BFT 。在这项工作中，我们专注于部分同步。

**主分区与可分区成员服务**。成员服务可以是主分区的或可分区的 [11]。在主分区服务中，所有副本的视图都是完全有序的。在可分区视图中，视图是部分排序的，即多个不相交的视图可能同时存在。论文只研究主分区模型

**动态组通信**。组成员问题和视图同步通信问题首先由 **Birman 和 Joseph** [7] 讨论。组成员身份抽象提供了活跃成员的动态但一致的视图。 ==View synchronous communication [7, 47] 扩展组成员以支持视图成员内的可靠广播==。扩展的虚拟同步 [37] 扩展了虚拟同步，确保消息传递与所有副本的配置更改之间保持一致的关系。 ==Spread [5] 和 Secure Spread [4] 包含崩溃故障模型中的虚拟同步和扩展虚拟同步。 Secure Spread 通过身份验证、完整性、访问控制和机密性增强了 Spread==。 **Chockler** 等人[11] 对动态组通信系统进行了全面调查：首先定义组成员服务（用于添加和删除进程），然后在第二步中指定通信原语（例如，可靠广播、原子广播）。在这些系统中，群组成员服务是各种通信栈的基础层。相比之下，Schiper 的规范首先描述通信原语，然后描述成员变化，并允许所有成员变化来自成员请求的显式调用 [46]。例如，为原子广播定义的原语称为动态原子广播，或简称为原子多播。 Schiper 认为这种选择会导致更“自然”和更简单的规范。 Schiper [46] 还表明，他的规范在活性属性方面与 [11] 中调查的规范仅略有不同。 **Guerraoui** 等最近提出了动态拜占庭可靠广播（DBRB），其中副本可以动态地加入和离开系统[20]。从定义的角度来看，DBRB 解决了一个与我们的（共识）相当不同的问题（广播），并且侧重于异步设置。从技术角度来看，DBRB 允许不同的视图路径最终会收敛到同一视图。 **Rampart [39] 和 SecureRing [25]** 在拜占庭故障模型中实现状态机复制，并依靠拜占庭故障检测器实现活性。

**重新配置原子存储**。动态原子读/写 (R/W) 存储可以是基于共识的 [19, 36, 44] 和无共识的。阿奎莱拉等在 DynaStore [2] 中证明动态原子存储可以在异步设置中解决，无需使用共识（或随机化）。从 DynaStore 开始，已经提出了许多无共识的动态原子存储结构（例如 [3, 18, 23]）。 Kuznetsov 和 Tonkikh 提出了具有拜占庭故障的异步原子存储 [28]。

**SMR 的重新配置**。Lamport 在 Paxos 中提出将成员更改作为系统状态的一部分进行管理 [30]。在就成员请求达成一致后，副本在安装新配置之前等待 α 批请求执行。Lorch等人提出了 SMART [34]，其中系统的重新配置是通过创建一组额外的副本来管理的。这两组副本运行并行的 Paxos 实例，直到系统状态完全迁移到新组。对于主/备份复制，在崩溃故障设置中研究了重新配置的解决方案 [22、49]。 **Raft [38] 提出了一种用于重构的两阶段方法。第一阶段是称为联合共识的过渡配置。为了过渡到新的配置，两种配置中的副本都参与联合共识，而协议是独立维护的。这种方法允许旧配置中的副本继续为客户端提供服务，并允许新配置中的副本赶上历史。只有在提交了联合共识后，系统才会移动到新的配置。 BFT-SMaRt 是一个支持重新配置的 BFT 系统 [50]，其中成员请求被视为一种特殊类型的客户端请求，并将所有请求一起排序。我们的系统也使用这种策略**。但是单独这样做而不进一步修改协议，可能会产生活性问题（零吞吐量），正如我们将在第 四节中展示任何基于领导者的 BFT 协议理论以及在第八节中实验性地展示 BFT-SMaRt 。

**使用辅助主站重新配置**。系统（存储、SMR 或主备份复制）的重新配置可以由辅助主服务器管理 [31、35、43]。例如，Vertical Paxos 表明（在崩溃失败设置中）使用 f + 1 个副本来构建管理 SMR 配置的配置主机就足够了。

**会员管理**。动态 BFT 与成员管理形成鲜明对比，成员管理是管理分布式系统中节点的服务 [12、13、24、32、41、42、45、52]。该服务可以从独立的 SMR（例如 Apache Zookeeper [21]、Google Chubby [9]）构建，也可以通过成员的自我发现（例如 SWIM [13]）构建。相比之下，动态 BFT 是一种根本不同的原语，可以将其视为可自配置的 SMR。

**耐用性**。持久性是一种在状态机复制系统崩溃或关闭后幸存下来并使恢复副本保持最新状态的能力。该属性之前已在静态组的上下文中考虑 [6, 10]，而我们从不同的角度考虑动态组的类似属性。

### system and threat model

#### A. 静态BFT

传统的拜占庭容错 (BFT) 协议有一组恒定的副本，其中一部分可能会任意失败（拜占庭失败）。在 BFT 中，副本传递请求，每个请求都由客户端提交。一个请求可能包括一个或多个操作。副本执行请求中的操作并向相应的客户端发送回复。客户端根据回复消息计算最终响应。在具有 n 个副本的系统中，BFT 容忍 f ≤ ⌊ (n−1) /3 ⌋ 拜占庭故障，这是最优的。 BFT 的正确性指定如下：

* Agreement一致性：如果正确的副本交付请求 m，则每个正确的副本最终交付 m。
* Total order全序：如果一个正确的副本在传递m′之前传递消息m，那么另一个正确的副本只有在传递m之后才传递消息m′。 
* Liveness：如果一个正确的客户端提交了一个请求m，那么一个正确的副本最终会交付m。 
* Integrity完整性：没有正确的副本多次传递相同的消息m；如果一个正确的副本传递了一条消息 m 并且提交 m 的客户端是正确的，那么 m 之前是由客户端提交的。 

Total order 和 integrity 是安全属性，而另外两个是 liveness 属性。一致性和活跃性一起意味着客户最终会收到有效的响应。 BFT 形式化可以显式地为客户端请求分配序列号，并要求正确的副本根据顺序执行请求。

一般来说，部分同步的拜占庭容错协议依赖于视图更改（以领导者轮换的形式）来实现活跃性，因此在视图中进行。当领导者出现故障时（例如，PBFT [10]）或根据某种策略（例如，Spinning [53]、HotStuff [55]）定期触发时，将触发视图更改。但是，异步 BFT 协议没有视图更改机制。

#### B. 动态BFT

我们考虑一个 BFT 系统，其副本取自有限集 Π = {p1, p2, · · · }（也称为宇宙）。每个副本 pi ∈ Π 都有一个公钥/私钥对 (pki, ski)，为简单起见，我们假设其公钥为集合中的所有进程所知，并用作 pi 的唯一标识符。动态 BFT 组由 Π 的子集组成。 BFT 组中的副本是该组的成员。我们使用配置的概念来表示 BFT 组的连续成员。设 Mc 是由整数 c 编号的配置的成员（副本组），初始化为 0（初始配置）。副本通过配置安装更改其配置。我们引入以下定义

**定义 III.1**。副本 p 处于配置 c，如果 p ∈ Mc。

**定义 III.2**。 p 的（当前）配置是 c，如果 p 已经安装了配置 c 但没有在 c 之后安装另一个配置。

**定义 III.3**。如果至少有一个正确的副本安装了 c，并且没有正确的副本安装了 c′，则系统的最新配置为 c，其中 c′ > c。

**定义 III.4**。副本 p 在配置 c 中是正确的，如果 p 安装了配置 c，并且 p 在 c 中是正确的（不是错误的）。 （注意 p 在配置 c + 1 中可能有故障也可能没有故障，但在 c 中没有故障。）

**定义 III.5**。副本 p 是 c-正确的，如果 1) p 在配置 c 中是正确的，并且 2) c 中没有正确的副本安装任何大于 c 的配置，或者 c 中的某些正确副本在 c 和 p ∈ Mc 之后安装配置 c + 1 +1。 （如果 c 是 c 中所有正确副本的最新配置，或者 p 在 c 的下一个配置中，则 p 是 c 正确的。

**定义 III.6**。如果 p ∈ Mc 并且 p 不是 c-正确的，则副本 p 是 c-错误的。 （副本 p 在配置 c 中可能是正确的，但c-faulty，例如，p 可能恰好在配置 c 之后但在配置 c + 1 之前从组中删除，并且永远不会在配置 c + 1 中。）

**定义 III.7**。副本 p 是 g-正确的，如果 1) p 是 0-正确的（其中 0 是系统的初始配置），并且 2) 不存在 c > 0 这样 p 不是 c-正确的。 （g 正确的复制品在其所有配置中都是正确的。）

**定义 III.8**。副本 p 对于 c ≥ 0 是 gc-正确的，如果 1) p 是 c-正确的，并且 2) 不存在 c' 使得 c' > c 并且 p 不是 c'-正确的。 （gc-correct 副本在配置 c'≥c 中是正确的。g0-correct 副本是 g-correct。）


#### C. 动态 BFT 的组成员更改

我们考虑两个可以修改成员资格的成员资格请求：将新副本添加到组的**加入请求**和从组中删除副本的**离开请求**。成员资格请求不同于不更改成员资格的常规 BFT 请求（写入和读取请求）。我们不失一般性地==假设成员资格请求是修改成员资格的唯一方法==。我们对谁可以提出会员申请没有任何限制。它们可以被任何授权的客户端调用（例如，加入或离开系统的副本、系统管理员、受信任的 CA、高级程序）。我们也不讨论为什么包含或排除副本，而只介绍我们如何这样做。事实上，如第一节中的示例所示，通常在同意谁将加入或离开小组以及为什么和何时需要更改小组成员资格方面没有歧义。

在配置 c 中的副本 pj 处执行对 pi 的加入请求后，pj 的成员资格变为 Mc ∪ {pi}（相应地 pj 安装新配置）。在配置 c 中的副本 pj 执行对 pi 的离开请求后，其成员资格变为 $M_c-\{p_i\}$。

对于 i < j 的两个配置成员 Mi 和 Mj，我们使用 Mj /Mi 来表示 Mj 中存在但 Mi 中不存在的副本。例如，如果 Mi = {p2, p3, p4} 和 Mj = {p3, p4, p5, p6}，则 Mj /Mi = {p5, p6}。令 nc 和 tc 分别为配置 c 中的副本数和 c-faulty 副本数。在配置 c 中，我们有 nc = |Mc|。

#### D. 假设

**标准法定人数假设** ：我们在这项工作中假设了最佳弹性模型。即，系统在配置 c 中可以容忍的最大故障数是 fc ≤ ⌊(nc -1) / 3 ⌋。副本的法定人数至少包括 ⌈(nc +fc +1) / 2⌉。我们使用 Qc 来表示配置 c 中的成员最低数量。这是一个标准的和最优的假设。除非另有说明，否则我们考虑默认假设

**G-正确假设**：我们还考虑了一个更强的假设，该假设不是必需的，但在某些情况下可能会产生一些（很多）更简单的协议。对于所有 c ≥ 0，设 F = max({fc}) + 1。G 正确假设要求至少存在 F 个副本，这些副本在所有配置中都是正确的。换句话说，==“足够”正确的副本永远不会离开系统==。

此外，我们对动态成员资格做出两个标准假设（用于所有其他此类场景）：首先，加入或离开系统的副本数量是有界的（一个自然的假设是从配置 c 到 c + 1，至少Qc个 c-正确的副本还在c+1)；其次，初始配置为宇宙中的所有副本所知。

#### E. Property specification

在我们的形式化中，成员请求和常规 BFT 请求可以统称为请求。我们以与常规请求相同的方式处理成员资格请求。因此，在下面指定动态 BFT 的正确性时，请求 m 可以是成员请求或常规请求。特别是，加入或离开请求的调用只是特殊客户端请求的调用。加入（或 离开）请求的执行对应于通过请求中的添加（或 移除）操作传递请求和安装新配置。
